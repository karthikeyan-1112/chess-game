<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Chess Master</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
    :root {
        --light-square: #53524e;
        --dark-square: #6d8346;
        --highlight: #a3d3a3;
        --valid-move: #85d58588;
        --last-move: #edffed6b;
        --capture-move: #cc555566;
    }
    body {
        margin: 0;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: #242933;
        color: #ffe;
        min-height: 100vh;
    }
    .container {
        display: flex;
        flex-direction: row;
        gap: 36px;
        justify-content: center;
        margin-top: 24px;
        flex-wrap: wrap;
    }
    .board-panel { }
    .chessboard {
        display: grid;
        grid-template-columns: repeat(8, 56px);
        grid-template-rows: repeat(8, 56px);
        border: 2px solid #181c20;
        border-radius: 10px;
        box-shadow: 0 6px 32px #0008;
        background: #181c20;
    }
    .square {
        width: 56px;
        height: 56px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2.5em;
        position: relative;
        cursor: pointer;
        user-select: none;
    }
    .white { background: var(--light-square); }
    .black { background: var(--dark-square); }
    /* Removed piece highlight borders */
    .selected { box-shadow: none !important; }
    .valid-move { box-shadow: none !important; }
    .capture::before { display: none !important; }
    .last-move { background: var(--last-move) !important; }
    .piece { z-index: 2; }
    .white-piece {
        color: #fff !important;
        text-shadow: 0 1px 4px #adadad22, 0 0 1px #9997;
        font-weight: 50;
    }
    .black-piece {
        color: #1a1a1a !important;
        text-shadow: 0 0 1px #0008; 
        font-weight: 50;
    }
    .ui-panel {
        background: #181c20cc;
        border-radius: 10px;
        box-shadow: 0 2px 18px #0007;
        padding: 18px 14px;
        width: 260px;
        display: flex;
        flex-direction: column;
        gap: 18px;
        min-width: 260px;
        max-width: 95vw;
    }
    .major-btn-group {
        display: flex;
        flex-direction: column;
        gap: 9px;
    }
    button {
        padding: 10px 0;
        font-size: 1em;
        border: none;
        background: linear-gradient(135deg, #b1d8b1, #6d8346);
        color: #fff;
        font-weight: 600;
        box-shadow: 0 3px 10px #4a6e4a99;
        border-radius: 8px;
        cursor: pointer;
        transition: background 0.3s ease, color 0.3s ease;
    }
    button:hover {
        background: linear-gradient(135deg, #95c195, #468036);
        color: #fff;
    }
    #undoBtn:disabled {
        background: #b9b9b9;
        color: #777;
        cursor: not-allowed;
        box-shadow: none;
    }
    .move-history {
        font-family: 'JetBrains Mono', 'Courier New', monospace;
        font-size: 1em;
        background: #242933;
        color: #e0e0d9;
        border-radius: 5px;
        max-width: 100%;
        white-space: nowrap;
        overflow-x: auto;
        overflow-y: hidden;
        padding: 5px 8px;
        margin-bottom: 12px;
        box-shadow: inset 0 0 10px #3a4a2f99;
    }
    .status-bar {
        background: #6d8346;
        padding: 10px 0;
        margin-bottom: 10px;
        font-weight: 700;
        border-radius: 10px;
        text-align: center;
        color: #e4f0e2;
        font-size: 1.2em;
        min-height: 32px;
        box-shadow: inset 0 0 8px #8daa6985;
    }
    .select-promotion {
        display: flex;
        gap: 12px;
        align-items: center;
        justify-content: center;
        margin: 16px 0;
    }
    .promotion-btn {
        font-size: 1.4em;
        background: #a3d3a3;
        color: #264326;
        padding: 10px 16px;
        border-radius: 8px;
        box-shadow: 0 2px 8px #517b36aa;
        cursor: pointer;
        transition: background 0.3s ease;
    }
    .promotion-btn:hover {
        background: #6d8346;
        color: #dae5bd;
    }
    /* Mode selection buttons */
    .mode-select-group {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-bottom: 18px;
    }
    .mode-btn {
        background: #557a3e;
        color: #e4f0e2;
        border-radius: 10px;
        border: none;
        font-size: 1.1em;
        padding: 12px 0;
        cursor: pointer;
        font-weight: 700;
        box-shadow: 0 3px 10px #385122bb;
        transition: background 0.25s ease;
    }
    .mode-btn.active, .mode-btn:active {
        background: #a3d3a3;
        color: #264326;
        box-shadow: 0 3px 10px #517b36cc;
    }
    .confirm-btn {
        font-weight: 700;
        background: #517b36;
        color: #d3ead3;
        border-radius: 10px;
        padding: 12px 0;
        cursor: pointer;
        transition: background 0.3s ease;
        box-shadow: 0 5px 10px #00000077;
    }
    .confirm-btn:hover {
        background: #6d8346;
    }
    #sideSelect {
        margin-left: 4px;
        padding: 8px 6px;
        border-radius: 8px;
        border: 1px solid #8da06c;
        width: 75%;
        max-width: 140px;
        background: #557a3e;
        color: #e4f0e2;
        font-weight: 700;
        box-shadow: inset 0 0 5px #3a4a2fbb;
        cursor: pointer;
    }
    @media (max-width: 850px) {
        .container {
            flex-direction: column;
            align-items: center;
        }
        .ui-panel {
            width: 100vw;
            max-width: 350px;
        }
        .chessboard {
            grid-template-columns: repeat(8, 10vw);
            grid-template-rows: repeat(8, 10vw);
            max-width: 90vw;
        }
        .square { font-size: 7vw; }
    }
</style>
</head>
<body>
<h1 style="text-align:center;letter-spacing:1px;margin:14px 0 3px 0;">♛ Chess Master</h1>
<div class="status-bar" id="statusBar">Select mode and click Confirm to start the game.</div>
<div class="container">
    <div class="board-panel">
        <div style="position:relative; width:480px; height:480px;">
            <!-- Board image as background, grid overlays on top -->
            <img src="images/chess board.png" alt="Chess Board" style="position:absolute;top:0;left:0;width:480px;height:480px;z-index:0;border-radius:10px;box-shadow:0 6px 32px #0008;">
            <!-- The grid is sized to fit only the inner squares (8x8), not the border -->
            <div id="chessboard" class="chessboard"
                 style="position:absolute;top:32px;left:32px;width:416px;height:416px;z-index:1;"></div>
        </div>
    </div>
    <div class="ui-panel">
        <div class="major-btn-group">
            <button id="resetBtn">⟳ Reset</button>
        </div>
        <div id="modeSelectGroup" class="mode-select-group">
            <button id="pvpBtn" class="mode-btn active">Player vs Player</button>
            <button id="pvbBtn" class="mode-btn">Player vs Bot</button>
            <select id="sideSelect" style="display:none;">
                <option value="white">You play White</option>
                <option value="black">You play Black</option>
            </select>
            <button id="confirmModeBtn" class="confirm-btn">Confirm</button>
        </div>
        <div>
            <div style="margin-bottom:5px;font-weight:600;">Move History</div>
            <div id="moveHistory" class="move-history"></div>
        </div>
        <!-- Removed Make Bot Move button -->
    </div>
</div>
<div id="promotionPopup" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;align-items:center;justify-content:center;background:rgba(20,20,30,0.7);z-index:20;">
    <div style="background:#444;border-radius:15px;padding:26px 32px;text-align:center;color:var(--light-square);max-width:320px;">
        <div style="font-size:1.4em;margin-bottom:1em;">Choose Promotion</div>
        <div class="select-promotion">
            <button class="promotion-btn" data-piece="queen">♛</button>
            <button class="promotion-btn" data-piece="rook">♜</button>
            <button class="promotion-btn" data-piece="bishop">♝</button>
            <button class="promotion-btn" data-piece="knight">♞</button>
        </div>
    </div>
</div>

<script>
// Get references to DOM elements
const modeSelectGroup = document.getElementById('modeSelectGroup');
const pvpBtn = document.getElementById('pvpBtn');
const pvbBtn = document.getElementById('pvbBtn');
const confirmBtn = document.getElementById('confirmModeBtn');
const sideSelect = document.getElementById('sideSelect');
const resetBtn = document.getElementById('resetBtn');
const statusBar = document.getElementById('statusBar');
const historyPanel = document.getElementById('moveHistory');
const chessboard = document.getElementById('chessboard');
const promotionPopup = document.getElementById('promotionPopup');

// SVG file mapping by piece type and color
const pieceSvgMap = {
  PAWN:   { white: "images/White_Pawn.svg",   black: "images/Black_Pawn.svg" },
  ROOK:   { white: "images/White_Rook.svg",   black: "images/Black_Rook.svg" },
  KNIGHT: { white: "images/White_Knight.svg", black: "images/Black_Knight.svg" },
  BISHOP: { white: "images/White_Bishop.svg", black: "images/Black_Bishop.svg" },
  QUEEN:  { white: "images/White_Queen.svg",  black: "images/Black_Queen.svg" },
  KING:   { white: "images/White_King.svg",   black: "images/Black_King.svg" }
};

let gameMode = 'player';      // 'player' or 'bot'
let playerSide = 'white';     // chosen side if bot
let modeConfirmed = false;
let currentTurn = 'white';
let selected = null;
let moveHistory = [];
let validMoves = [];
let lastMove = null;
let boardState = null;
let promotionMove = null;
let gameStarted = false;
let gameOver = false;

function botSide(){
  return playerSide === 'white' ? 'black' : 'white';
}

// Update active mode button and side selector visibility
function updateModeButtons() {
  pvpBtn.classList.toggle('active', gameMode === 'player');
  pvbBtn.classList.toggle('active', gameMode === 'bot');
  sideSelect.style.display = gameMode === 'bot' ? 'block' : 'none';
}

// Mode buttons handlers
pvpBtn.onclick = () => {
  gameMode = 'player';
  updateModeButtons();
};
pvbBtn.onclick = () => {
  gameMode = 'bot';
  updateModeButtons();
};
sideSelect.onchange = () => {
  playerSide = sideSelect.value;
};

// Capitalize helper
function capitalize(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}

// Confirm button to start game and hide mode selection
confirmBtn.onclick = () => {
  modeConfirmed = true;
  modeSelectGroup.style.display = 'none';

  resetGame().then(success => {
    if (!success) return;

    gameStarted = true;
    gameOver = false;

    // Freeze side selection & hide after start (prevents mid-game switching)
    sideSelect.disabled = true;
    sideSelect.style.display = 'none';

    updateStatus(`${capitalize(currentTurn)} to move`);

    // If bot should start, trigger it safely
    if (gameMode === 'bot' && currentTurn === botSide()) {
      setTimeout(makeBotMove, 120);
    }
  });
};

// Reset button resets game and shows mode selector again
resetBtn.onclick = () => {
  resetGame().then(success => {
    if(!success) return;

    modeConfirmed = false;
    gameStarted = false;
    gameOver = false;

    modeSelectGroup.style.display = '';
    sideSelect.style.display = 'none';
    sideSelect.disabled = false;

    updateStatus('Select mode and click Confirm to start');
    moveHistory = [];
    updateMoveHistory();
  });
};

function updateStatus(msg){
  statusBar.innerHTML = msg || '';
}

function updateMoveHistory(){
  let html = '';
  for(let i=0; i<moveHistory.length; i+=2){
    const moveNumber = (i / 2) + 1;
    const whiteMove = moveHistory[i] || '';
    const blackMove = moveHistory[i+1] || '';
    html += `<span>${moveNumber}. ${whiteMove} ${blackMove}</span> `;
  }
  historyPanel.innerHTML = html.trim();
}

function getBoardSquare(row, col){
  return boardState?.[row]?.[col];
}

function renderBoard(boardData){
  chessboard.innerHTML = '';
  chessboard.style.background = "none";
  chessboard.style.border = "none";
  chessboard.style.borderRadius = "0";
  chessboard.style.boxShadow = "none";
  chessboard.style.width = "416px";
  chessboard.style.height = "416px";
  chessboard.style.position = "absolute";
  chessboard.style.top = "32px";
  chessboard.style.left = "32px";
  chessboard.style.display = "grid";
  chessboard.style.gridTemplateColumns = "repeat(8, 52px)";
  chessboard.style.gridTemplateRows = "repeat(8, 52px)";

  for(let r=0; r<8; r++){
    for(let c=0; c<8; c++){
      const sq = document.createElement('div');
      sq.className = 'square';
      sq.style.background = "none";
      sq.dataset.row = r;
      sq.dataset.col = c;
      sq.style.width = "52px";
      sq.style.height = "52px";

      if(lastMove && ((r === lastMove.fromRow && c === lastMove.fromCol) ||
                      (r === lastMove.toRow && c === lastMove.toCol))) {
        sq.classList.add('last-move');
      }

      const piece = boardData[r][c];
      if(piece){
        const img = document.createElement('img');
        img.src = pieceSvgMap[piece.type][piece.color];
        img.alt = piece.type;
        img.style.width = "44px";
        img.style.height = "44px";
        img.style.pointerEvents = "none";
        img.draggable = gameStarted && !gameOver;
        sq.appendChild(img);
      }

      sq.addEventListener('click', () => handleSquareClick(r, c));
      sq.addEventListener('dragover', e => e.preventDefault());
      sq.addEventListener('drop', e => {
        e.preventDefault();
        handleDrop(r, c);
      });

      chessboard.appendChild(sq);
    }
  }
}
function initBoardGrid() {
  chessboard.innerHTML = '';
  chessboard.style.background = "none";
  chessboard.style.border = "none";
  chessboard.style.borderRadius = "0";
  chessboard.style.boxShadow = "none";
  chessboard.style.width = "416px";
  chessboard.style.height = "416px";
  chessboard.style.position = "absolute";
  chessboard.style.top = "32px";
  chessboard.style.left = "32px";
  chessboard.style.display = "grid";
  chessboard.style.gridTemplateColumns = "repeat(8, 52px)";
  chessboard.style.gridTemplateRows = "repeat(8, 52px)";

  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const sq = document.createElement('div');
      sq.className = 'square';
      sq.style.background = "none";
      sq.dataset.row = r;
      sq.dataset.col = c;
      sq.style.width = "52px";
      sq.style.height = "52px";

      sq.addEventListener('click', () => handleSquareClick(r, c));
      sq.addEventListener('dragover', e => e.preventDefault());
      sq.addEventListener('drop', e => {
        e.preventDefault();
        handleDrop(r, c);
      });

      chessboard.appendChild(sq);
    }
  }
}


function loadBoard(){
  fetch('/board')
    .then(r => r.json())
    .then(data => {
      boardState = data;
      renderBoard(data);
    });
}

function fetchValidMoves(row, col){
  fetch('/valid-moves', {
    method: 'POST',
    headers: {'Content-Type':'application/json'},
    body: JSON.stringify({row, col})
  }).then(r => r.json())
    .then(res => {
      if(res.success){
        validMoves = res.validMoves;
        renderBoard(boardState);
      }
    });
}

function sendMove(move){
  hidePromotion();
  fetch('/move', {
    method: 'POST',
    headers: {'Content-Type':'application/json'},
    body: JSON.stringify(move)
  }).then(r => r.json())
    .then(res => {
      if(res.success){
        currentTurn = res.currentTurn;
        lastMove = {
          fromRow: move.fromRow,
          fromCol: move.fromCol,
          toRow: move.toRow,
          toCol: move.toCol
        };
        selected = null;
        validMoves = [];
        moveHistory = res.moveHistory || moveHistory;
        boardState = null;
        updateMoveHistory();
        handleGameStatus(res.gameStatus);
        loadBoard();
        if(gameMode === 'bot' && currentTurn === botSide() && !gameOver){
          setTimeout(makeBotMove, 600);
        }
      } else {
        alert(res.message);
      }
    }).catch(() => alert('Error communicating with server.'));
}

function makeBotMove(){
  if(gameOver) return;
  if(currentTurn !== botSide()) return; // Only move when it's bot's turn
  fetch('/bot-move', {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({color: botSide()})
  }).then(r => r.json())
    .then(res => {
      if(res.success){
        lastMove = parseMoveString(res.move);
        currentTurn = res.currentTurn;
        moveHistory = res.moveHistory || moveHistory;
        updateMoveHistory();
        handleGameStatus(res.gameStatus);
        loadBoard();
      } else {
        alert(res.message);
      }
    });
}

function parseMoveString(str){
  if(!str || str.length < 4) return null;
  const fromCol = str.charCodeAt(0) - 97;
  const fromRow = 8 - (+str[1]);
  const toCol = str.charCodeAt(2) - 97;
  const toRow = 8 - (+str[3]);
  return {fromRow, fromCol, toRow, toCol};
}

function handleSquareClick(row, col){
  if(!gameStarted || gameOver) return;
  const sq = getBoardSquare(row, col);
  if(!selected){
    if(!sq) return;
    if(gameMode === 'bot' && sq.color !== playerSide) return;
    if(sq.color !== currentTurn) return;
    selected = {row, col, color: sq.color};
    fetchValidMoves(row, col);
  } else {
    if(selected.row === row && selected.col === col){
      selected = null;
      validMoves = [];
      renderBoard(boardState);
      return;
    }
    if(validMoves.some(m => m.row === row && m.col === col)){
      const promotionNeeded = (selected.color === 'white' && row === 0) || (selected.color === 'black' && row === 7);
      if(promotionNeeded && getBoardSquare(selected.row, selected.col).type === 'PAWN'){
        promotionMove = {fromRow: selected.row, fromCol: selected.col, toRow: row, toCol: col, color: selected.color};
        showPromotion();
      } else {
        sendMove({fromRow: selected.row, fromCol: selected.col, toRow: row, toCol: col, color: selected.color});
      }
    } else {
      selected = null;
      validMoves = [];
      renderBoard(boardState);
    }
  }
}

function handleDrop(row, col){
  if(!selected) return;
  const pawn = getBoardSquare(selected.row, selected.col);
  if(!pawn) return;
  if(validMoves.some(m => m.row === row && m.col === col)){
    const promotionRequired = (pawn.color === 'white' && row === 0) || (pawn.color === 'black' && row === 7);
    if(promotionRequired && pawn.type === 'PAWN'){
      promotionMove = {fromRow: selected.row, fromCol: selected.col, toRow: row, toCol: col, color: pawn.color};
      showPromotion();
    } else {
      sendMove({fromRow: selected.row, fromCol: selected.col, toRow: row, toCol: col, color: pawn.color});
    }
  }
}

function hidePromotion(){
  promotionPopup.style.display = 'none';
  promotionMove = null;
}

function showPromotion(){
  promotionPopup.style.display = 'flex';
}

promotionPopup.querySelectorAll('.promotion-btn').forEach(btn => {
  btn.onclick = () => {
    if(!promotionMove) return;
    promotionMove.promotion = btn.dataset.piece;
    sendMove(promotionMove);
    hidePromotion();
  };
});

function handleGameStatus(status){
  if(status.startsWith('checkmate')){
    gameOver = true;
    const winner = status.includes('white') ? 'Black' : 'White';
    updateStatus(`${winner} wins by checkmate!`);
  } else if(status === 'stalemate'){
    gameOver = true;
    updateStatus('Game drawn by stalemate.');
  } else if(status === 'draw'){
    gameOver = true;
    updateStatus('Game drawn.');
  } else if(status.startsWith('check')){
    updateStatus('Check!');
  } else {
    gameOver = false;
    updateStatus(`${capitalize(currentTurn)} to move`);
  }
}

function resetGame(){
  return fetch('/reset', {method:'POST'})
    .then(r => r.json())
    .then(res => {
      if(res.success){
        currentTurn = 'white';
        selected = null;
        moveHistory = [];
        validMoves = [];
        lastMove = null;
        boardState = null;
        gameStarted = false;
        gameOver = false;
        updateMoveHistory();
        loadBoard();
        return true;
      }
      return false;
    });
}

window.onload = () => {
  updateModeButtons();
  modeSelectGroup.style.display = '';
  sideSelect.style.display = 'none';
  sideSelect.disabled = false;
  updateStatus('Select mode and click Confirm to start');
  loadBoard();
};
</script>
</body>
</html>