<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Master</title>
    <style>
        :root {
            --light-square: #f0d9b5;
            --dark-square: #b58863;
            --highlight: rgba(0, 200, 255, 0.5);
            --valid-move: rgba(0, 255, 0, 0.5);
            --capture-move: rgba(255, 0, 0, 0.3);
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #2c3e50;
            color: white;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            color: #f1c40f;
            text-shadow: 0 0 10px rgba(241, 196, 15, 0.5);
            margin-bottom: 5px;
        }
        .mode-selector {
    margin-bottom: 15px;
    background: #34495e;
    padding: 10px 15px;
    border-radius: 8px;
    color: white;
}
        .status {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 15px;
            border-radius: 20px;
            margin-bottom: 20px;
            font-weight: bold;
        }
        .game-container {
            display: flex;
            gap: 30px;
            max-width: 1000px;
            width: 100%;
            justify-content: center;
            flex-wrap: wrap;
        }
        .board-container {
            background: #34495e;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            border: 2px solid #2c3e50;
            width: 480px;
            height: 480px;
        }
        .square {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            cursor: pointer;
            position: relative;
        }
        .white { background: var(--light-square); }
        .black { background: var(--dark-square); }
        .white-piece { color: white; text-shadow: 1px 1px 3px #333; }
        .black-piece { color: #222; text-shadow: 1px 1px 2px #777; }
        .selected { background-color: var(--highlight) !important; }
        .valid-move { background-color: var(--valid-move) !important; }
        .capture::before {
            content: "";
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: var(--capture-move);
        }
        .controls {
            background: #34495e;
            padding: 20px;
            border-radius: 10px;
            width: 250px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        .control-group {
            margin-bottom: 20px;
        }
        h2 {
            color: #f1c40f;
            border-bottom: 2px solid #f1c40f;
            padding-bottom: 5px;
        }
        button {
            background: #f1c40f;
            color: #2c3e50;
            border: none;
            padding: 10px 15px;
            margin: 5px 0;
            width: 100%;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        button:hover {
            background: #f39c12;
            transform: translateY(-2px);
        }
        .turn-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
        }
        .turn-circle {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #2c3e50;
        }
        .white-turn { background: var(--light-square); }
        .black-turn { background: var(--dark-square); }
        .active-turn {
            box-shadow: 0 0 0 3px #f1c40f;
        }
        .debug-panel {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
            width: 100%;
            max-width: 800px;
            font-family: monospace;
            overflow: auto;
            max-height: 200px;
        }
        @media (max-width: 768px) {
            .chessboard {
                grid-template-columns: repeat(8, 40px);
                grid-template-rows: repeat(8, 40px);
                width: 320px;
                height: 320px;
            }
            .square {
                width: 40px;
                height: 40px;
                font-size: 30px;
            }
        }
    </style>
</head>
<body>
    <h1>Chess Master</h1>
    <div class="mode-selector">
    <label>
        <input type="radio" name="mode" value="player" checked> Player vs Player
    </label>
    <label>
        <input type="radio" name="mode" value="bot"> Player vs Bot
    </label>
    <select id="sideSelect">
        <option value="white" selected>You play White</option>
        <option value="black">You play Black</option>
    </select>
</div>
    <div class="status" id="gameStatus">Loading game...</div>
    <div class="game-container">
        <div class="board-container">
            <div class="chessboard" id="chessboard">Loading board...</div>
        </div>
        <div class="controls">
            <div class="control-group">
                <h2>Game Controls</h2>
                <button id="resetBtn">Reset Game</button>
            </div>
            <div class="control-group">
                <h2>Player Turn</h2>
                <div class="turn-indicator">
                    <div class="turn-circle white-turn" id="whiteTurn"></div>
                    <span>White</span>
                    <div class="turn-circle black-turn" id="blackTurn"></div>
                    <span>Black</span>
                </div>
                <button id="botMoveBtn">Make Bot Move</button>
            </div>
        </div>
    </div>
    <script>
        let gameMode = "player"; // "player" or "bot"
let playerSide = "white"; // used in bot mode
// Handle mode and side selection
document.querySelectorAll('input[name="mode"]').forEach(el => {
    el.addEventListener("change", () => {
        gameMode = el.value;
        document.getElementById("sideSelect").style.display = gameMode === "bot" ? "inline-block" : "none";
        resetGame();
    });
});
document.getElementById("sideSelect").addEventListener("change", (e) => {
    playerSide = e.target.value;
    resetGame();
});
        // Add deffuncTug logging
        const debugPanel = document.getElementById('debugPanel');
        const pieceMap = {
            PAWN: "♟", ROOK: "♜", KNIGHT: "♞", BISHOP: "♝", 
            QUEEN: "♛", KING: "♚"
        };
        let selectedPiece = null;
        let validMoves = [];
        let currentTurn = "white";
        let gameOver = false;
        // DOM elements
        const gameStatus = document.getElementById('gameStatus');
        const whiteTurn = document.getElementById('whiteTurn');
        const blackTurn = document.getElementById('blackTurn');
        const resetBtn = document.getElementById('resetBtn');
        const botMoveBtn = document.getElementById('botMoveBtn');
        const chessboard = document.getElementById('chessboard');
        // Initialize event listeners
        resetBtn.addEventListener('click', resetGame);
        botMoveBtn.addEventListener('click', makeBotMove);
        function updateTurnIndicator() {
            if (currentTurn === "white") {
                whiteTurn.classList.add('active-turn');
                blackTurn.classList.remove('active-turn');
                gameStatus.textContent = "White's Turn";
            } else {
                blackTurn.classList.add('active-turn');
                whiteTurn.classList.remove('active-turn');
                gameStatus.textContent = "Black's Turn";
            }
        }
        function loadBoard() {
            fetch("/board")
                .then(res => {
                    if (!res.ok) {
                        throw new Error(`HTTP error! status: ${res.status}`);
                    }
                    return res.json();
                })
                .then(data => {
                    renderBoard(data);
                })
                .catch(error => {
                    chessboard.innerHTML = "Error loading board. See debug panel.";
                });
        }
        function renderBoard(boardData) {
    chessboard.innerHTML = "";

    for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
            const cell = document.createElement("div");
            const isWhite = (i + j) % 2 === 0;
            cell.className = `square ${isWhite ? "white" : "black"}`;
            cell.dataset.row = i;
            cell.dataset.col = j;

            const piece = boardData[i][j];
            if (piece) {
                const symbol = pieceMap[piece.type] || "?";
                const pieceElem = document.createElement("span");
                pieceElem.textContent = symbol;
                pieceElem.className = piece.color.toLowerCase() + "-piece";
                pieceElem.setAttribute("draggable", "true");

                // Drag start
                pieceElem.addEventListener("dragstart", () => {
                    dragStart = { row: i, col: j, color: piece.color };
                });

                cell.appendChild(pieceElem);
            }

            // Allow drop
            cell.addEventListener("dragover", (e) => e.preventDefault());

            // Drop logic
            cell.addEventListener("drop", (e) => {
                e.preventDefault();
                if (!dragStart) return;

                const move = {
                    fromRow: dragStart.row,
                    fromCol: dragStart.col,
                    toRow: i,
                    toCol: j,
                    color: dragStart.color
                };
                sendMove(move);
                dragStart = null;
            });

            // Also allow click-based move
            cell.addEventListener("click", () => handleCellClick(i, j, piece));
            chessboard.appendChild(cell);
        }
    }
}


function handleCellClick(row, col, piece) {
    if (gameOver) {
        return;
    }
    if (!selectedPiece) {
        if (piece && piece.color === currentTurn && (gameMode === "player" || playerSide === piece.color))
 {
            selectedPiece = { row, col, color: piece.color };
            calculateValidMoves(row, col, piece);
        }
    } else {
        if (selectedPiece.row === row && selectedPiece.col === col) {
            selectedPiece = null;
            validMoves = [];
            loadBoard();
            return;
        }
        const isValidMove = validMoves.some(move =>
            move.row === row && move.col === col
        );
        if (isValidMove) {
            const move = {
                fromRow: selectedPiece.row,
                fromCol: selectedPiece.col,
                toRow: row,
                toCol: col,
                color: selectedPiece.color
            };
            sendMove(move);
        } else {
            }
        selectedPiece = null;
        validMoves = [];
    }
}
        function calculateValidMoves(row, col, piece) {
            validMoves = [];
            fetch("/valid-moves", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ row, col })
            })
            .then(res => res.json())
            .then(data => {
                if (data.success && data.validMoves) {
                    validMoves = data.validMoves;
                    loadBoard();
                } else {
                    }
            })
            .catch(error => {
                });
        }
        function sendMove(move) {
    fetch("/move", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(move)
    })
    .then(res => res.json())
    .then(response => {
        if (response.success) {
            currentTurn = response.currentTurn || (currentTurn === "white" ? "black" : "white");
            updateTurnIndicator();
            loadBoard();
            // ✅ Bot should move immediately after player if in bot mode
            if (gameMode === "bot" && currentTurn !== playerSide) {
                setTimeout(makeBotMove, 500);
            }
            const status = response.gameStatus;
            if (status?.startsWith("checkmate")) {
                gameOver = true;
                const winner = status.includes("white") ? "Black" : "White";
                alert(`Checkmate! ${winner} wins!`);
            } else if (status === "stalemate") {
                gameOver = true;
                alert("Stalemate! Game ends in a draw.");
            } else if (status === "draw") {
                gameOver = true;
                alert("Game drawn!");
            }
        } else {
            alert(response.message);
        }
    })
    .catch(error => {
        alert('Move failed!');
    });
}
function makeBotMove() {
    if (gameOver) {
        return;
    }
    fetch("/bot-move", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ color: currentTurn })
    })
    .then(res => res.json())
    .then(response => {
        if (response.success) {
            currentTurn = response.currentTurn || (currentTurn === "white" ? "black" : "white");
            updateTurnIndicator();
            loadBoard();
            const status = response.gameStatus;
            if (status?.startsWith("checkmate")) {
                gameOver = true;
                const winner = status.includes("white") ? "Black" : "White"; // white got checkmated = black wins
                alert(`Checkmate! ${winner} wins!`);
            } else if (status === "stalemate") {
                gameOver = true;
                alert("Stalemate! Game ends in a draw.");
            } else if (status === "draw") {
                gameOver = true;
                alert("Game drawn!");
            }
        } else {
            if (response.gameStatus?.includes("checkmate") || response.gameStatus === "draw") {
                gameOver = true;
                alert(response.message); // backend already set the message
            } else {
                alert("Bot move failed: " + response.message);
            }
        }
    })
    .catch(error => {
        alert("Error making bot move");
    });
}
        function resetGame() {
            fetch("/reset", {
                method: "POST"
            })
            .then(res => res.json())
            .then(response => {
                if (response.success) {
                    selectedPiece = null;
                    validMoves = [];
                    currentTurn = "white";
                    gameOver = false;
                    updateTurnIndicator();
                    loadBoard();
                } else {
                    alert('Reset failed: ' + response.message);
                }
            })
            .catch(error => {
                alert('Error resetting game');
            });
        }
        then(response => {
    if (response.success) {
        currentTurn = response.currentTurn || (currentTurn === "white" ? "black" : "white");
        updateTurnIndicator();
        loadBoard();
        if (response.gameStatus?.includes("checkmate")) {
            gameOver = true;
            alert("Checkmate! Game over.");
        } else if (response.gameStatus === "stalemate" || response.gameStatus === "draw") {
            gameOver = true;
            alert("Game ended in a draw.");
        } else if (gameMode === "bot" && currentTurn !== playerSide) {
            setTimeout(makeBotMove, 500);
        }
    }
});
        // Initialize the game
        updateTurnIndicator();
        loadBoard();
    </script>
</body>
</html>